print('helloworld')
a -> 2
a <- 2
a
czxc
q()
a <- 0
b <- 10
disp(a + b)
q()
q()
library(grpreg)
library(R.matlab)
dat <- readMat("glm_input_2.mat")
setwd("C:/Users/nikit/Downloads/Epilepsy-Research-Project/Connectivity_analysis_source_data/P1/P1_S6")
library(grpreg)
library(R.matlab)
dat <- readMat("glm_input_2.mat")
X <- dat$X
y <- as.vector(dat$y)
# Hard-coded for your case: 4 regions x 5 lags each = 20 columns
# Group structure must match column ordering in X:
# [self (target), region2, region3, region4], each block size 5
group <- rep(1:4, each=5)
# Fit Poisson group-lasso path (lambda grid is built automatically)
fit <- grpreg(X, y, group=group, penalty="grLasso", family="poisson")
p <- ncol(X)
G <- length(unique(group))
L <- length(fit$lambda)
# drop intercept
B <- fit$beta[-1, , drop = FALSE]
group_norms <- matrix(0, nrow = G, ncol = L)
for (g in 1:G) {
idx <- which(group == g)
group_norms[g, ] <- apply(B[idx, , drop = FALSE], 2, function(v) sqrt(sum(v^2)))
}
group_norms > 0
plot(fit$lambda, fit$loss, log = "x",
xlab = "lambda", ylab = "Deviance")
library(grpreg)
library(R.matlab)
dat <- readMat("glm_input_3.mat")
X <- dat$X
y <- as.vector(dat$y)
# Hard-coded for your case: 4 regions x 5 lags each = 20 columns
# Group structure must match column ordering in X:
# [self (target), region2, region3, region4], each block size 5
group <- rep(1:4, each=5)
# Fit Poisson group-lasso path (lambda grid is built automatically)
fit <- grpreg(X, y, group=group, penalty="grLasso", family="poisson")
p <- ncol(X)
G <- length(unique(group))
L <- length(fit$lambda)
# drop intercept
B <- fit$beta[-1, , drop = FALSE]
group_norms <- matrix(0, nrow = G, ncol = L)
for (g in 1:G) {
idx <- which(group == g)
group_norms[g, ] <- apply(B[idx, , drop = FALSE], 2, function(v) sqrt(sum(v^2)))
}
group_norms > 0
plot(fit$lambda, fit$loss, log = "x",
xlab = "lambda", ylab = "Deviance")
h
p <- ncol(X)
G <- length(unique(group))
L <- length(fit$lambda)
# drop intercept
B <- fit$beta[-1, , drop = FALSE]
group_norms <- matrix(0, nrow = G, ncol = L)
for (g in 1:G) {
idx <- which(group == g)
group_norms[g, ] <- apply(B[idx, , drop = FALSE], 2, function(v) sqrt(sum(v^2)))
}
group_norms > 0
plot(fit$lambda, fit$loss, log = "x",
xlab = "lambda", ylab = "Deviance")
