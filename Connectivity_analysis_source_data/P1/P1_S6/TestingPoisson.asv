load('test_2_node.mat')
%%


patientNo = 1;

numDelays_self  = 5;
numDelays_cross = 5;



region = 1;

y_region = Y(region,:).';

self_history = historicalVec(numDelays_self, y_region);  



cross_history = [];


n = size(Y,1);
for i = 1:n
    if i == region
        continue;                                  
    end
    increment_curr = Y(i, :).';             
    curr_region_history = historicalVec(numDelays_cross, increment_curr);      
    cross_history = [cross_history, curr_region_history];           % concatenating regions
end


X = [self_history, cross_history];   % getting self and cross history
y = y_region;                       


% mdl = fitglm(X,y,'linear','Distribution','poisson','Link','log');


% [B, FitInfo] = lassoglm(X, y, 'poisson', 'Standardize', false); % get 100 lambdas
L = max(numDelays_self, numDelays_cross);
X = X(L+1:end, :);
y = y_region(L+1:end);


otherRegions = setdiff(1:n, region, 'stable');

group = ones(1, numDelays_self);   % group 1 = self

g = 2;
for i = 1:length(otherRegions)
    group = [group, g * ones(1, numDelays_cross)];
    g = g + 1;
end

% Sanity check
assert(length(group) == size(X,2), 'Group vector length must equal ncol(X).');

save('glm_input_2_node_1.mat', 'X', 'y', 'group', ...
     'region', 'numDelays_self', 'numDelays_cross');



% Save for R
% save('glm_input_2_node_1.mat', 'X', 'y', 'region', 'numDelays_self', 'numDelays_cross')
%% gather statistics


% fprintf('Number of ')



% X()

% figure;
% subplot(2,1,1)
% stem(y_region), title('Raw y')
% 
% subplot(2,1,2)
% stem(X(:,1)), title('Self lag 1 (previous point)')


load('grpreg_path.mat')


% Ensure correct shapes
X = double(X);
y = double(y(:));
Lambda = Lambda(:).';      % make it 1 x L

Intercept = Beta(1, :);    % 1 x L
B = Beta(2:end, :);        % p x L

L = length(Lambda);
tol = 1e-8;

LL  = zeros(1, L);
df  = zeros(1, L);
AIC = zeros(1, L);

for k = 1:L
    eta = Intercept(k) + X * B(:, k);   % T x 1
    mu  = exp(eta);                     % Poisson rate

    % Exact Poisson log-likelihood
    LL(k) = sum( y .* log(mu) - mu - gammaln(y + 1) );

    % Degrees of freedom: intercept + nonzero coefficients
    df(k) = 1 + sum(abs(B(:, k)) > tol);

    % AIC
    AIC(k) = -2 * LL(k) + 2 * df(k);
end

% Find minimum AIC
[bestAIC, idx] = min(AIC);
bestLambda = Lambda(idx);

fprintf('Minimum AIC = %.6f\n', bestAIC);
fprintf('Best lambda = %.6g\n', bestLambda);
fprintf('Degrees of freedom = %d\n', df(idx));




plot(Lambda,AIC,'-o');


% 

