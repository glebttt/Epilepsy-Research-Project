

TT = readtable("softpriors_counts_and_times_per_channel.xlsx",'Sheet','filtered_datafeature_based_o_5');
fs = 256;
fields = {'p_spike_1_0_times','p_poly_1_0_times','p_sw_1_0_times'};

n = height(TT);
spike_times_channels = cell(n,1);

for i = 1:n
    all_t = [];
    for f = 1:numel(fields)
        s = TT.(fields{f}){i};
        if ~isempty(s)
            t = str2num(s); 
            all_t = [all_t, t];
        end
    end
    spike_times_channels{i} = all_t;

end

% Binary spike trains
binary_trains = cell(n,1);
for i = 1:n
    t = spike_times_channels{i};
    if isempty(t)
        binary_trains{i} = [];
    else
        idx = unique(round(t * fs));
        v = zeros(idx(end),1);
        v(idx) = 1;
        binary_trains{i} = v;
    end
end

% for i = 1:5
%     figure;
%     time = (0:length(binary_trains{i})-1)/fs;
%     stem(time, binary_trains{i});
%     xlabel('Time (s)');
%     ylabel('Spike response');
%     title(sprintf('Channel %d', i));
% end




%% This code is for combining all channels into a single spike train (to be changed to selected channels)
% finidng the longest of the binary spike trains
maxlen = 0;
for i = 1:n
    L = length(binary_trains{i});
    if L > maxlen
        maxlen = L;
    end
end


% ensuring that all binary spike trains are same size as the biggest
% channel
padded_binary_trains = false(n, maxlen);
for i = 1:n
    binary_train_channel = binary_trains{i};
    L = length(binary_train_channel);
    padded_binary_trains(i, 1:L) = binary_train_channel;   
    
end



% getting the combined spike train 
combined_train = false(maxlen,1);

% combined_train = zeros(maxlen,1);  

% 
for i = 1:n
    binary_train_channel = padded_binary_trains(i,:);
    binary_train_channel = binary_train_channel.';

    L = length(binary_train_channel);
    combined_train(1:L) = combined_train(1:L) | binary_train_channel;  


end


% Plot combined spike train
% time = (0:length(combined_train)-1)/fs;
% figure;
% stem(time, combined_train);
% xlabel('Time (s)');
% ylabel('Combined spike response');
% title('Combined multi-channel spike train');


%%

total_sum = 0;
for i=1:length(binary_trains)
    total_sum = total_sum + sum(binary_trains{i});
end



%%


TT = readtable("spike_data_with_mni_reduced");
fs = 256;
field= 'all_spike_times';

n = height(TT);
spike_times_regions = cell(n,1);

for i = 1:n
    all_t = [];
        s = TT.(field){i};
        if ~isempty(s)
            t = str2num(s); 
            all_t = [all_t, t];
        end
   spike_times_channels{i} = all_t;

end


% Binary spike trains
nonpadded_binary_trains_regions = cell(n,1);
for i = 1:n
    t = spike_times_channels{i};
    if isempty(t)
        nonpadded_binary_trains_regions{i} = [];
    else
        idx = unique(round(t * fs));
        v = zeros(idx(end),1);
        v(idx) = 1;
        nonpadded_binary_trains_regions{i} = v;
    end
end


%% choose region


% padding (basically all binary spike trains for regions have the same)

% This is if we want to finish the sequence at the length of the
% biggest binary spike train (but here we choose the region's of interest
% legth)
% maxlen = 0;
% for i = 1:n
%     L = length(nonpadded_binary_trains_regions{i});
%     if L > maxlen
%         maxlen = L;
%     end
% end


% % region = 1;
% % maxlen = length(nonpadded_binary_trains_regions{region});
% 
% % ensuring that all binary spike trains are same size as the biggest
% % channel
% binary_trains_regions = false(n, maxlen);
% for i = 1:n
%     binary_train_region = nonpadded_binary_trains_regions{i};
%     L = length(binary_train_region);
%     binary_trains_regions(i, 1:L) = binary_train_region;   % after L filled up with zeros
% 
% end

region = 1;  % region of interest (can be any 1..n)
maxLen = length(nonpadded_binary_trains_regions{region});

binary_trains_regions = false(n, maxLen);

% padding operation so that all other regions have the same size binary
% spike train to train a specific region
for i = 1:n
    binary_train_region = nonpadded_binary_trains_regions{i};
    L = length(binary_train_region);

    lengt_current = min(L, maxLen);
    binary_trains_regions(i, 1:lengt_current) = binary_train_region(1:lengt_current);
end

%% turn into time-lagged matrix 


% first bin the binary spike train

binSize = 5/fs; % this is approx. 20 ms if we want to set a specific amount of ms 
% (desired_ms*256)/1000 here desired_ms = 20


% this is just to get correct dims the increments for the first 2
% dimensions of next variable containing the increments pe region
[increments_region, ~] =spikeIncrements(binary_trains_regions(region,:),binSize,fs);


% increments for all regions based on the binsize - 1 spike occured in bin , else 0
increments_all_regions = zeros(length(increments_region),n);
for i=1:n
    [increments_region, ~] =spikeIncrements(binary_trains_regions(i,:),binSize,fs);
    increments_all_regions(:,i) = increments_region;

end


 


%% Creating input matrices for a region model 

% setting self and cross coupling past history (now 0.2 and 0.1 secs
% respecitvely)
pastTimeSelf = 0.2;  
pastTimeCross = 0.1;  

numDelays_self  = floor(pastTimeSelf/binSize);
numDelays_cross = floor(pastTimeCross/binSize);



y_region = increments_all_regions(:, region);      
self_history = historicalVec(numDelays_self, y_region);  



cross_history = [];

for i = 1:n
    if i == region
        continue;                                  
    end
    increment_curr = increments_all_regions(:, i);             
    curr_region_history = historicalVec(numDelays_cross, increment_curr);      
    cross_history = [cross_history, curr_region_history];           % concatenating regions
end


X = [self_history, cross_history];   % getting self and cross history
y = y_region;                       


%%

total = 0;
for j = 1:n
    if j == region
        continue;
    end

    total = total + (nnz(increments_all_regions(:,j) == 1)*numDelays_cross);
end


total = total + (nnz(increments_all_regions(:,region) == 1)*numDelays_self);


